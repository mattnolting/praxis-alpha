#!/usr/bin/env bun

/**
 * @praxis/generate - NATIVE FILE WATCHING IMPLEMENTATION
 * True event-driven with native FS events - no polling!
 */

import { createNativeWatcher, type WatchEvent } from './quick-native-watcher.ts';
import { loadConfig, type PraxisConfig } from './config-parser.ts';

// üöÄ NATIVE FILE WATCHER - True event-driven with FS events
const nativeWatcher = createNativeWatcher();

// ============================================================================
// PURE BUN FILE OPERATIONS
// ============================================================================

function createOutputFile(configPath: string, componentName: string, extension: string): string {
  const lastSlash = configPath.lastIndexOf('/');
  const directory = lastSlash >= 0 ? configPath.substring(0, lastSlash) : '.';
  return `${directory}/${componentName}${extension}`;
}

function getFileBaseName(filePath: string): string {
  const lastSlash = filePath.lastIndexOf('/');
  return lastSlash >= 0 ? filePath.substring(lastSlash + 1) : filePath;
}

async function shouldRegenerate(configPath: string, outputPath: string): Promise<boolean> {
  try {
    const [configStat, outputStat] = await Promise.all([
      Bun.file(configPath).stat(),
      Bun.file(outputPath).stat()
    ]);
    return configStat.mtime > outputStat.mtime;
  } catch {
    return true;
  }
}

async function writeGeneratedFile(filePath: string, content: string) {
  try {
    await Bun.write(filePath, content);
    console.log(`‚úÖ Generated: ${getFileBaseName(filePath)}`);
  } catch (error) {
    console.error(`‚ùå Failed to write: ${filePath}`, error);
  }
}

// ============================================================================
// SIMPLE GENERATION FUNCTIONS
// ============================================================================

function generateFromUsesDeclaration(usesDeclaration: any, componentName: string): string {
  const interfaceName = `${componentName}Props`;
  const props: string[] = [];

  for (const [category, items] of Object.entries(usesDeclaration)) {
    if (category === 'variants') {
      const variantValues = (items as string[]).map(item => `"${item}"`).join(' | ');
      props.push(`  /** Component variant */\n  variant?: ${variantValues};`);
    } else if (category === 'sizes') {
      const sizeValues = (items as string[]).map(item => `"${item}"`).join(' | ');
      props.push(`  /** Component size */\n  size?: ${sizeValues};`);
    } else if (category === 'states') {
      for (const item of items as string[]) {
        props.push(`  /** Component state: ${item.replace('is', '').toLowerCase()} */\n  ${item}?: boolean;`);
      }
    } else if (category === 'accessibility') {
      for (const item of items as string[]) {
        props.push(`  /** Accessibility: ${item} */\n  ${item}?: string;`);
      }
    } else if (category === 'interactions') {
      for (const item of items as string[]) {
        props.push(`  /** Event handler: ${item} */\n  ${item}?: (...args: any[]) => any;`);
      }
    } else if (category === 'styling') {
      for (const item of items as string[]) {
        const type = item === 'style' ? 'React.CSSProperties' : 'string';
        props.push(`  /** Styling: ${item} */\n  ${item}?: ${type};`);
      }
    }
  }

  return `/**
 * Generated props for ${componentName}
 * DO NOT EDIT - Generated by Praxis using registry
 */

export interface ${interfaceName} {
${props.join('\n')}
}

export default ${interfaceName};
`;
}

function generateJSONSchema(config: PraxisConfig): string {
  const componentName = config.component?.name || 'Component';
  let properties = {};

  if (config.uses) {
    for (const [category, items] of Object.entries(config.uses)) {
      if (category === 'variants') {
        properties = { ...properties, variant: { type: "string", description: "Component variant", enum: items } };
      } else if (category === 'sizes') {
        properties = { ...properties, size: { type: "string", description: "Component size", enum: items } };
      } else if (category === 'states') {
        for (const item of items as string[]) {
          properties = { ...properties, [item]: { type: "boolean", description: `Component state: ${item.replace('is', '').toLowerCase()}` } };
        }
      } else if (category === 'accessibility') {
        for (const item of items as string[]) {
          properties = { ...properties, [item]: { type: "string", description: `Accessibility: ${item}` } };
        }
      } else if (category === 'interactions') {
        for (const item of items as string[]) {
          properties = { ...properties, [item]: { type: "string", description: `Event handler: ${item}` } };
        }
      } else if (category === 'styling') {
        for (const item of items as string[]) {
          properties = { ...properties, [item]: { type: "string", description: `Styling: ${item}` } };
        }
      }
    }
  }

  const schema = {
    $schema: "http://json-schema.org/draft-07/schema#",
    title: `${componentName} Props`,
    type: "object",
    properties,
    required: []
  };

  return JSON.stringify(schema, null, 2);
}

export async function generateTypeScript(configPath: string): Promise<void> {
  const config = await loadConfig(configPath);
  if (!config) return;

  const componentName = config.component.name;
  const outputPath = createOutputFile(configPath, componentName, 'Props.ts');

  if (!(await shouldRegenerate(configPath, outputPath))) {
    console.log(`‚ö° Cached: ${componentName}Props.ts`);
    return;
  }

  let content: string;

  if (config.uses) {
    content = generateFromUsesDeclaration(config.uses, componentName);
  } else {
    content = `// No 'uses' declaration found in config`;
  }

  await writeGeneratedFile(outputPath, content);
}

export async function generateSchema(configPath: string): Promise<void> {
  const config = await loadConfig(configPath);
  if (!config) return;

  const componentName = config.component.name;
  const outputPath = createOutputFile(configPath, componentName, 'Schema.json');

  if (!(await shouldRegenerate(configPath, outputPath))) {
    console.log(`‚ö° Cached: ${componentName}Schema.json`);
    return;
  }

  const content = generateJSONSchema(config);
  await writeGeneratedFile(outputPath, content);
}

export async function generateAll(configPath: string, formats: string[] = ['typescript']): Promise<void> {
  console.log(`üöÄ Processing: ${getFileBaseName(configPath)}`);

  const promises = formats.map(format => {
    switch (format) {
      case 'typescript':
        return generateTypeScript(configPath);
      case 'json-schema':
        return generateSchema(configPath);
      default:
        console.warn(`Unknown format: ${format}`);
        return Promise.resolve();
    }
  });

  await Promise.all(promises);
}

export async function scanAndGenerate(dir: string = '.'): Promise<void> {
  console.log('üîç Scanning for Praxis configs...');

  const glob = new Bun.Glob('**/*.praxis.yaml');
  const configs = await Array.fromAsync(glob.scan(dir));

  console.log(`Found ${configs.length} config files`);

  for (const configPath of configs) {
    await generateAll(configPath, ['typescript', 'json-schema']);
  }

  console.log(`‚úÖ Generated interfaces for ${configs.length} components`);
}

// ============================================================================
// üöÄ NATIVE FILE WATCHING - True event-driven with FS events
// ============================================================================

export async function watchAndGenerate(dir: string = '.'): Promise<void> {
  console.log('üëÄ Starting native file watcher...');

  // Initial generation
  await scanAndGenerate(dir);

  console.log('üöÄ Using native event-driven file watching...');

  // Use native file watcher - NO POLLING!
  await nativeWatcher.watch('**/*.praxis.yaml', async (events: WatchEvent[]) => {
    console.log(`üì¶ Processing ${events.length} file events...`);

    // Process each unique file once (debouncing already handled)
    const uniqueFiles = new Set(events.map(event => event.path));

    for (const filePath of uniqueFiles) {
      const event = events.find(e => e.path === filePath);

      if (event?.type === 'unlink') {
        console.log(`üóëÔ∏è File deleted: ${event.path}`);
        // Could clean up generated files here if needed
      } else {
        console.log(`üîÑ Config changed: ${filePath}`);
        try {
          await generateAll(filePath, ['typescript', 'json-schema']);
        } catch (error) {
          console.error(`‚ùå Generation failed for ${filePath}:`, error);
        }
      }
    }

    // Show watcher stats periodically
    const stats = nativeWatcher.getStats();
    console.log(`üìä Watcher: Native FS events, ${stats.watcherType}`);
  });

  console.log('üöÄ Native file watching active... (Press Ctrl+C to stop)');

  // Cleanup on exit
  process.on('SIGINT', () => {
    console.log('\nüìã Cleaning up native watcher...');
    nativeWatcher.stop();
    process.exit(0);
  });
}

// ============================================================================
// COMMAND LINE USAGE
// ============================================================================

if (import.meta.main) {
  const args = process.argv.slice(2);
  const command = args[0];

  switch (command) {
    case 'generate':
      await scanAndGenerate(args[1]);
      break;

    case 'watch':
      await watchAndGenerate(args[1]);
      break;

    case 'single':
      if (args[1]) {
        await generateAll(args[1], ['typescript', 'json-schema']);
      } else {
        console.error('Usage: bun generate.ts single <config-path>');
      }
      break;

    default:
      console.log(`
üöÄ Praxis Generate - 100% Bun-Native Implementation

Usage:
  bun generate.ts generate [dir]     # Scan and generate all
  bun generate.ts watch [dir]        # Watch for changes
  bun generate.ts single <config>    # Generate single file

Examples:
  bun generate.ts generate          # Process current directory
  bun generate.ts watch             # Watch current directory
  bun generate.ts single TestButton.praxis.yaml
`);
  }
}

export default {
  generateTypeScript,
  generateSchema,
  generateAll,
  scanAndGenerate,
  watchAndGenerate
};