#!/usr/bin/env bun
// @bun

// packages/vite-plugin/index.ts
import { watch } from "fs";
import { join } from "path";
function parseSimpleYAML(content) {
  const lines = content.split(`
`).filter((line) => line.trim() && !line.trim().startsWith("#"));
  const result = {};
  let currentSection = result;
  let currentKey = "";
  for (const line of lines) {
    const trimmed = line.trim();
    if (trimmed.includes(":")) {
      const [key, value] = trimmed.split(":").map((s) => s.trim());
      if (value === "" || value === undefined) {
        currentSection[key] = {};
        currentKey = key;
      } else if (value.startsWith("[") && value.endsWith("]")) {
        const arrayStr = value.slice(1, -1);
        const items = arrayStr.split(",").map((s) => s.trim().replace(/["']/g, ""));
        currentSection[key] = items;
      } else {
        currentSection[key] = value.replace(/["']/g, "");
      }
    } else if (trimmed.startsWith("-")) {
      if (!Array.isArray(currentSection[currentKey])) {
        currentSection[currentKey] = [];
      }
      currentSection[currentKey].push(trimmed.slice(1).trim().replace(/["']/g, ""));
    }
  }
  return result;
}
async function loadSimpleConfig(filePath) {
  try {
    const file = Bun.file(filePath);
    const content = await file.text();
    const config = parseSimpleYAML(content);
    if (!config.component?.name) {
      console.warn(`\u26A0\uFE0F Missing component.name in ${filePath}`);
      return null;
    }
    return config;
  } catch (error) {
    console.error(`\u274C Failed to load config: ${filePath}`, error);
    return null;
  }
}
function praxis(options = {}) {
  const {
    watch: enableWatch = true,
    patterns = ["**/*.praxis.yaml"],
    outputDir = "src/types",
    formats = ["typescript", "json-schema"],
    verbose = false
  } = options;
  let server = undefined;
  let watchers = [];
  const generatedFiles = new Map;
  const log = (message) => {
    if (verbose) {
      console.log(`\uD83D\uDD25 [praxis] ${message}`);
    }
  };
  function generateTypeScript(config) {
    const { component, uses } = config;
    const props = [];
    for (const [category, items] of Object.entries(uses)) {
      if (category === "variants") {
        const variantValues = items.map((item) => `"${item}"`).join(" | ");
        props.push(`  /** Component variant */
  variant?: ${variantValues};`);
      } else if (category === "sizes") {
        const sizeValues = items.map((item) => `"${item}"`).join(" | ");
        props.push(`  /** Component size */
  size?: ${sizeValues};`);
      } else if (category === "states") {
        for (const item of items) {
          props.push(`  /** Component state: ${item.replace("is", "").toLowerCase()} */
  ${item}?: boolean;`);
        }
      } else if (category === "accessibility") {
        for (const item of items) {
          props.push(`  /** Accessibility: ${item} */
  ${item}?: string;`);
        }
      } else if (category === "interactions") {
        for (const item of items) {
          props.push(`  /** Event handler: ${item} */
  ${item}?: (...args: any[]) => any;`);
        }
      } else if (category === "styling") {
        for (const item of items) {
          const type = item === "style" ? "React.CSSProperties" : "string";
          props.push(`  /** Styling: ${item} */
  ${item}?: ${type};`);
        }
      }
    }
    return `/**
 * Generated props for ${component.name}
 * DO NOT EDIT - Generated by Praxis using Vite plugin
 * @generated ${new Date().toISOString()}
 */

export interface ${component.name}Props {
${props.join(`
`)}
}

export default ${component.name}Props;
`;
  }
  function generateJSONSchema(config) {
    const { component, uses } = config;
    const properties = {};
    for (const [category, items] of Object.entries(uses)) {
      if (category === "variants") {
        properties.variant = { type: "string", description: "Component variant", enum: items };
      } else if (category === "sizes") {
        properties.size = { type: "string", description: "Component size", enum: items };
      } else if (category === "states") {
        for (const item of items) {
          properties[item] = { type: "boolean", description: `Component state: ${item.replace("is", "").toLowerCase()}` };
        }
      }
    }
    const schema = {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: `${component.name} Props`,
      type: "object",
      properties,
      required: [],
      additionalProperties: false
    };
    return JSON.stringify(schema, null, 2);
  }
  async function processConfigFile(configPath) {
    try {
      log(`Processing ${configPath}`);
      const config = await loadSimpleConfig(configPath);
      if (!config) {
        console.warn(`\u26A0\uFE0F [praxis] Failed to load config: ${configPath}`);
        return;
      }
      const componentName = config.component.name;
      const outputs = new Map;
      if (formats.includes("typescript")) {
        outputs.set("typescript", generateTypeScript(config));
      }
      if (formats.includes("json-schema")) {
        outputs.set("json-schema", generateJSONSchema(config));
      }
      await Bun.write(`${outputDir}/.gitkeep`, "");
      for (const [format, content] of outputs) {
        const extension = format === "typescript" ? "Props.ts" : "Schema.json";
        const outputPath = join(outputDir, `${componentName}${extension}`);
        await Bun.write(outputPath, content);
        const generatedFile = {
          path: outputPath,
          content,
          timestamp: Date.now()
        };
        generatedFiles.set(outputPath, generatedFile);
        log(`Generated ${outputPath}`);
        if (server && format === "typescript") {
          server.ws?.send({
            type: "full-reload"
          });
        }
      }
      console.log(`\u2705 [praxis] Generated interfaces for ${componentName}`);
    } catch (error) {
      console.error(`\u274C [praxis] Error processing ${configPath}:`, error);
    }
  }
  async function scanAndProcess() {
    log("Scanning for Praxis config files...");
    try {
      const glob = new Bun.Glob("**/*.praxis.yaml");
      const configs = await Array.fromAsync(glob.scan("."));
      console.log(`\uD83D\uDD0D [praxis] Found ${configs.length} config files`);
      await Promise.all(configs.map(processConfigFile));
      console.log(`\u2705 [praxis] Processed ${configs.length} components`);
    } catch (error) {
      console.error("\u274C [praxis] Error scanning configs:", error);
    }
  }
  function setupWatching() {
    if (!enableWatch)
      return;
    log("Setting up file watching...");
    const watcher = watch(".", { recursive: true }, async (eventType, filename) => {
      if (!filename || !filename.endsWith(".praxis.yaml"))
        return;
      log(`File ${eventType}: ${filename}`);
      setTimeout(async () => {
        try {
          if (eventType === "change" || eventType === "rename") {
            try {
              await Bun.file(filename).stat();
              await processConfigFile(filename);
            } catch {
              log(`File deleted: ${filename}`);
            }
          }
        } catch (error) {
          console.error(`\u274C [praxis] Error handling file change:`, error);
        }
      }, 50);
    });
    watchers.push(watcher);
    console.log("\uD83D\uDC40 [praxis] File watching active for .praxis.yaml files");
  }
  return {
    name: "praxis",
    async buildStart() {
      log("Build started - processing Praxis configs");
      await scanAndProcess();
    },
    configureServer(devServer) {
      server = devServer;
      devServer.middlewares.use("/praxis-status", (req, res) => {
        res.setHeader("Content-Type", "application/json");
        res.end(JSON.stringify({
          generatedFiles: Array.from(generatedFiles.keys()),
          watchersActive: watchers.length,
          lastUpdate: Math.max(...Array.from(generatedFiles.values()).map((f) => f.timestamp))
        }));
      });
      setTimeout(async () => {
        await scanAndProcess();
        setupWatching();
      }, 100);
    },
    buildEnd() {
      watchers.forEach((watcher) => {
        try {
          watcher.close();
        } catch (error) {
          log(`Error closing watcher: ${error}`);
        }
      });
      watchers = [];
      if (watchers.length > 0) {
        log("File watchers stopped");
      }
    },
    async handleHotUpdate(ctx) {
      const { file } = ctx;
      if (file.endsWith(".praxis.yaml")) {
        log(`Hot update for ${file}`);
        await processConfigFile(file);
        return [];
      }
      return;
    }
  };
}
var vite_plugin_default = praxis;
export {
  praxis,
  vite_plugin_default as default
};
