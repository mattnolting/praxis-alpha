/**
 * @praxis/generate/core - Template Processors
 * ABSTRACTED: Eliminate repeated template building through cached generators
 * Performance: Pre-compiled templates vs runtime string construction
 */

// ============================================================================
// CACHED TEMPLATE GENERATORS (Eliminate String Building Overhead)
// ============================================================================

/**
 * Cached TypeScript interface template
 * Eliminates: Repeated interface string construction
 */
export const generateTypeScriptInterface = createCachedTemplate(
  (componentName: string, props: string[]): string => {
    const interfaceName = `${componentName}Props`;
    const propsContent = props.join('\n');
    
    return `/**
 * Generated props for ${componentName}
 * DO NOT EDIT - Generated by Praxis using registry
 */

export interface ${interfaceName} {
${propsContent}
}

export default ${interfaceName};
`;
  }
);

/**
 * Cached JSON Schema template
 * Eliminates: Repeated schema object construction
 */
export const generateJSONSchemaTemplate = createCachedTemplate(
  (componentName: string, properties: Record<string, any>): string => {
    const schema = {
      $schema: "http://json-schema.org/draft-07/schema#",
      title: `${componentName} Props`,
      type: "object",
      properties,
      required: [] // All props optional in uses() syntax
    };
    
    return JSON.stringify(schema, null, 2);
  }
);

/**
 * Cached prop comment template
 * Eliminates: Repeated comment string building
 */
export const generatePropComment = createCachedTemplate(
  (description: string): string => `  /** ${description} */\n`
);

/**
 * Cached union type template
 * Eliminates: Repeated union type string construction
 */
export const generateUnionType = createCachedTemplate(
  (values: string[]): string => values.map(v => `"${v}"`).join(' | ')
);

/**
 * Cached prop definition template
 * Eliminates: Repeated prop line construction  
 */
export const generatePropDefinition = createCachedTemplate(
  (propName: string, propType: string, description: string, isOptional: boolean = true): string => {
    const optional = isOptional ? '?' : '';
    const comment = generatePropComment(description);
    return `${comment}  ${propName}${optional}: ${propType};`;
  }
);

// ============================================================================
// SPECIALIZED TEMPLATE PROCESSORS
// ============================================================================

/**
 * Cached variant prop template
 * Eliminates: Repeated variant property generation
 */
export const generateVariantProp = createCachedTemplate(
  (values: string[]): string => {
    const unionType = generateUnionType(values);
    return generatePropDefinition('variant', unionType, 'Component variant');
  }
);

/**
 * Cached size prop template
 * Eliminates: Repeated size property generation
 */
export const generateSizeProp = createCachedTemplate(
  (values: string[]): string => {
    const unionType = generateUnionType(values);
    return generatePropDefinition('size', unionType, 'Component size');
  }
);

/**
 * Cached boolean prop template
 * Eliminates: Repeated boolean property generation
 */
export const generateBooleanProp = createCachedTemplate(
  (propName: string, description: string): string => {
    return generatePropDefinition(propName, 'boolean', description);
  }
);

/**
 * Cached function prop template
 * Eliminates: Repeated function property generation
 */
export const generateFunctionProp = createCachedTemplate(
  (propName: string, description: string): string => {
    return generatePropDefinition(propName, '(...args: any[]) => any', description);
  }
);

/**
 * Cached string prop template
 * Eliminates: Repeated string property generation
 */
export const generateStringProp = createCachedTemplate(
  (propName: string, description: string): string => {
    return generatePropDefinition(propName, 'string', description);
  }
);

// ============================================================================
// SCHEMA PROPERTY TEMPLATES
// ============================================================================

/**
 * Cached enum schema property template
 * Eliminates: Repeated enum schema object construction
 */
export const generateEnumSchemaProp = createCachedTemplate(
  (propName: string, values: string[], description: string): Record<string, any> => ({
    [propName]: {
      type: "string",
      description,
      enum: values
    }
  })
);

/**
 * Cached boolean schema property template
 * Eliminates: Repeated boolean schema object construction
 */
export const generateBooleanSchemaProp = createCachedTemplate(
  (propName: string, description: string): Record<string, any> => ({
    [propName]: {
      type: "boolean",
      description
    }
  })
);

/**
 * Cached string schema property template
 * Eliminates: Repeated string schema object construction
 */
export const generateStringSchemaProp = createCachedTemplate(
  (propName: string, description: string): Record<string, any> => ({
    [propName]: {
      type: "string",
      description
    }
  })
);

// ============================================================================
// MASTER TEMPLATE PROCESSOR
// ============================================================================

/**
 * Process complete component generation through cached templates
 * Eliminates: All template construction parsing overhead
 */
export function generateCompleteComponent(
  componentName: string,
  usesDeclaration: any
): { typescript: string; schema: string } {
  const props: string[] = [];
  const schemaProps: Record<string, any> = {};
  
  // Process each category using cached templates
  for (const [category, items] of Object.entries(usesDeclaration)) {
    const itemList = items as string[];
    
    switch (category) {
      case 'variants':
        props.push(generateVariantProp(itemList));
        Object.assign(schemaProps, generateEnumSchemaProp('variant', itemList, 'Component variant'));
        break;
        
      case 'sizes':
        props.push(generateSizeProp(itemList));
        Object.assign(schemaProps, generateEnumSchemaProp('size', itemList, 'Component size'));
        break;
        
      case 'states':
        itemList.forEach(item => {
          const description = `Component state: ${item.replace('is', '').toLowerCase()}`;
          props.push(generateBooleanProp(item, description));
          Object.assign(schemaProps, generateBooleanSchemaProp(item, description));
        });
        break;
        
      case 'accessibility':
        itemList.forEach(item => {
          const description = `Accessibility: ${item}`;
          props.push(generateStringProp(item, description));
          Object.assign(schemaProps, generateStringSchemaProp(item, description));
        });
        break;
        
      case 'interactions':
        itemList.forEach(item => {
          const description = `Event handler: ${item}`;
          props.push(generateFunctionProp(item, description));
          Object.assign(schemaProps, generateStringSchemaProp(item, description)); // JSON Schema limitation
        });
        break;
        
      case 'styling':
        itemList.forEach(item => {
          const description = `Styling: ${item}`;
          const propType = item === 'style' ? 'React.CSSProperties' : 'string';
          props.push(generatePropDefinition(item, propType, description));
          Object.assign(schemaProps, generateStringSchemaProp(item, description));
        });
        break;
    }
  }
  
  return {
    typescript: generateTypeScriptInterface(componentName, props),
    schema: generateJSONSchemaTemplate(componentName, schemaProps)
  };
}

// ============================================================================
// TEMPLATE FACTORY FUNCTION (Performance Core)
// ============================================================================

/**
 * Creates cached template functions
 * Performance: Template compiled once, cached forever
 */
function createCachedTemplate<T extends any[], R>(
  template: (...args: T) => R
): (...args: T) => R {
  const cache = new Map<string, R>();
  
  return (...args: T): R => {
    // Create cache key from arguments
    const cacheKey = JSON.stringify(args);
    
    if (cache.has(cacheKey)) {
      templateStats.cacheHits++;
      return cache.get(cacheKey)!;
    }
    
    // Compile once, cache forever
    const result = template(...args);
    cache.set(cacheKey, result);
    templateStats.cacheMisses++;
    
    return result;
  };
}

// ============================================================================
// PERFORMANCE TRACKING
// ============================================================================

let templateStats = {
  cacheHits: 0,
  cacheMisses: 0,
  get totalGenerations() { return this.cacheHits + this.cacheMisses; },
  get cacheHitRate() { return this.cacheHits / this.totalGenerations * 100; }
};

/**
 * Get template performance statistics
 */
export function getTemplateStats() {
  return { ...templateStats };
}

/**
 * Reset template performance statistics
 */
export function resetTemplateStats() {
  templateStats.cacheHits = 0;
  templateStats.cacheMisses = 0;
}

// ============================================================================
// TEMPLATE REGISTRY (Single Source of Truth)
// ============================================================================

/**
 * Registry of all available templates
 * Eliminates: Template lookup conditionals
 */
export const TEMPLATE_REGISTRY = {
  // TypeScript Templates
  typescript: {
    interface: generateTypeScriptInterface,
    variant: generateVariantProp,
    size: generateSizeProp,
    boolean: generateBooleanProp,
    function: generateFunctionProp,
    string: generateStringProp
  },
  
  // Schema Templates
  schema: {
    complete: generateJSONSchemaTemplate,
    enum: generateEnumSchemaProp,
    boolean: generateBooleanSchemaProp,
    string: generateStringSchemaProp
  },
  
  // Utility Templates
  utils: {
    comment: generatePropComment,
    union: generateUnionType,
    prop: generatePropDefinition
  }
} as const;

/**
 * Get template by path (cached lookup)
 */
export const getTemplate = createCachedTemplate(
  (templatePath: string) => {
    const parts = templatePath.split('.');
    let current: any = TEMPLATE_REGISTRY;
    
    for (const part of parts) {
      current = current[part];
      if (!current) return null;
    }
    
    return current;
  }
);
